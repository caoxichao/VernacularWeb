##### 1.forEach 和 map的区别
	forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

##### 2.Promise
> Promise是什么，解决了什么？
	Promise是异步编程的一种解决方案，比传统的解决方案—回调函数和事件—更合理和强大。解决了之前在请求回调产生的回调地狱，使得代码更加合理优雅，也更容易定位查找问题。
Promise.all()和Promise.race()的区别？
Promise.all()的使用：
1. 它接收一个数组作为参数
2. 数组可以是Promise对象，也可以是其他值，只有promise会等待状态改变
3. 当所有子Promise都完成，该Promise完成，返回值是全部值的数组
4. 如果有任意一个失败，该Promise失败，返回值是第一个失败的子Promise的效果
5. 应用场景：多个异步结果合并到一起
> Promise.race()的使用：
1. 和Promise.all()一样，但是不同的是，在第一个promise对象变为Fullfilled之后，并不会取消其他promise对象的执行。只是只有先完成的promise才会被后面的then处理。其他的promise还是在执行的，只不过是不会进入到promise.race后面的then内
2. 使用场景：把异步操作和定时器放到一起，如果定时器先触发，认为超时，告知用户。

##### 3.箭头函数和普通函数的区别
- 箭头函数是匿名函数，不能作为构造函数，因此不能使用new
- 箭头函数不绑定arguments，取而代之的使用rest参数代替
- 箭头函数不绑定this，但会捕获上下文的this，作为自己的this
- 箭头函数通过call()或者apply()方法调用一个函数时，只传入一个参数，对this没有影响。

##### 4.ES6新特性
1.	let和const
	let所声明的变量，只能在let命令所在的代码块内有效；const声明的变量
2.	字符串扩展
	新的API：includes(),startsWith(),endsWith()
3.	解构表达式，模板字符串
4.	map和reduce，filter
	map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回
	reduce()：接收一个函数(必须)和一个初始值(可选)，该函数接收两个参数：第一个参数是上一次reduce处理的结果，第二个参数是数组中要处理的下一个元素
	filter()：过滤掉不符合条件的
	forEach()：遍历。仅仅只是循环用，无返回值。
5.	promise
    所谓promise，简单来说就是一个容器，里面保存了某个未来才会结束的事件(通常是一个异步操作)的结果。
6.	set
7.	模块化
	模块化就是把代码进行拆分，方便重复利用，模块功能主要由两个命令构成：export和import
8.	对象扩展
	keys()和values()
9.	数组扩展
    find()、findIndex()、includes()
10.	函数参数默认值和箭头函数
##### 5.var、let和const的区别
1.	var声明的变量会挂载到window上，而let和const的变量不会
2.	var声明的变量存在变量提升，let和const不存在变量提升
3.	let和const声明形成块作用域
4.	同一作用域下，let和const不能声明同名变量，而var可以
5.	let声明的是变量，const声明的是常量，只读，修改值会报错，const保存的是内存地址，可以给数组或对象添加属性或元素，但是不能重复复写。
##### 6.判断是不是数组
1. instanceof 判断
```javascript
	var arr = [1,23,4]
	console.log(arr instanceof Array)
```
2. 原型链方法
```javascript
	var arr = [1,2,3]
	console.log(arr.__proto__.contructor == Array)
	console.log(arr.contructor == Array)
```
3. 通用方法
```javascript
	var arr = [1,2,3]
	console.log(Object.prototype.toString.call(arr) == '[object Array]')
```
4. typeof()
##### 7.async/await 和 Promise的区别
1. await会等待异步代码执行，会阻塞代码(使用时要考虑性能)
2. async/await在调试方面更加方便

##### 8.JavaScript可以有哪几种形式实现继承，各有什么优缺点？

|     类型     |                            优缺点                            |
| :----------: | :----------------------------------------------------------: |
| 构造函数模式 | 可以创建不同实例属性的副本，包括引用类型的实例属性，但是不能共享方法 |
|   原型模式   | 引用类型的属性对于实例对象而言共享同一个物理空间，因此可以共享方法 |
|    原型链    | 对父类实现方法和属性继承的过程中，父类实例对象的引用类型属性在子类的实例中共享同一个物理空间，因为父类的实例对象指向了子类的原型对象 |
| 借用构造函数 | 解决了继承中的引用值类型共享物理空间的问题，但是没法实现方法的共享 |
|   组合继承   | 属性的继承使用借用构造函数方法，方法的继承使用原型链技术，即解决了引用值类型共享的问题，又实现了方法的共享，但是子类的原型对象中还存在父类实例对象的实例属性 |
| 寄生组合继承 | 组合继承已经可以解决大部分问题，但是也有缺陷，就是会调用两次父类的构造函数，一次是实现原型时使子类的原型等于父类的实例对象调用了父类构造函数（同时在子类的原型对象中还存在了父类实例对象的实例属性），一次是使用子类构造函数时调用了一次父类构造函数。寄生组合式继承可以解决在继承的过程中子类的原型对象中还存在父类实例对象的实例属性的问题。 |

##### 9.cookie 和 session的区别
1. 存储数据量方面：session能够存储任意的java对象，cookie只能存储String类型的对象

2. 一个在客户端一个在服务端。因Cookie在客户端所以可以编辑伪造，不是十分安全

3. Session过多时会消耗服务器资源，大型网站会有专门的Session服务器，Cookie存在客户端没问题。

4. 域的支持范围不一样，比如说a.com的cookie在a.com下都能用，而 www.a.com 的session在api.a.com下都不能使用，解决这个问题的办法是JSONP或者跨域资源共享。

##### 10.什么是Event Loop?
> Event Loop是一个程序结构，用于等待和发送消息和事件。简单的说：就是在程序中设置两个线程，一个负责程序本身的运行，称为”主线程“；另一个负责主线程与其他线程(主要是各种I/O操作)的通信，被称为"Event Loop线程"(也可以译为消息线程)
> 宏任务：【浏览器】同步代码、UI Rendering、I/O、setTimeout、setInterval
> 微任务：【浏览器】Promise、MutationObserver

##### 11.null和undefined的区别？
- null转为数字类型为0，undefined转为数字类型为NaN
- undefined是代表一个值而该值却没有赋值，这时候默认为undefined
- null是一个很特殊的对象，最为常见的用法就是作为参数传入
- 设置为null的变量或者对象会被内存收集器回收。
##### 12.一个DOM元素绑定多个事件时，先执行冒泡还是捕获
	无论是冒泡事件还是捕获事件，元素都会先执行捕获阶段。从上往下，如果有捕获事件，则执行；一直下到目标元素后，从目标元素开始向上执行冒泡元素，即第三个参数为false的绑定事件的元素。(在向上执行过程中，已经执行过的捕获事件不再执行，只执行冒泡事件)
	事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层。优点：可以大量节省内存空间，减少事件注册；可以实现当新增子对象时无需再次对其绑定。
##### 13.apply、call和bind的区别
	在JavaScript中，call和apply都是为了改变某个函数运行时的上下文而存在的，换句话说就是为了改变函数体内部的this指向
	bind是返回对应函数，便于稍后使用;apply、call则是立即调用
	对于apply、call而言，作用完全一样，只是接受参数的方式不一样,前者参数是数组，后者是参数列表。
##### 14.合并数组&对象
1. for循环
2. concat()  // 不会改变原数组，而是返回一个新数组
3. apply() // Array.prototype.push.apply(arrA,arrB)
4. 扩展运算符
合并对象
1. Object.assign("目标对象","被合并对象")
2. 扩展运算符
##### 15.前端缓存
1. 强缓存

	不会向服务器发送请求，直接从缓存中读取资源。控制字段：Expires和Catch-control
2. 协商缓存

	向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存。控制字段：Last-Modified/If-Modified-Since 和 Etag/If-None-Match
3. HTML：使用协商缓存；CSS：使用强缓存，文件名带上hash值
##### 16.new做了什么？
1. 创建了一个全新的对象
2. 这个对象会被执行[[Prototype]](也就是__proto__)链接
3. 生成的新对象会绑定到函数调用的this
4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
5. 如果函数没有返回对象类型Object，那么new表达式中的函数调用会自动返回这个新的对象。
##### 17.继承
继承对于JS来说就是父类拥有的方法和属性、静态方法等，子类也要拥有。子类中可以利用原型链查找，也可以在子类中调用父类，或者从父类拷贝一份到子类等方案。继承方法可以有很多，重点在于必须理解并熟悉这些对象、原型以及构造器的工作方式，剩下的就简单了。寄生组合式继承是使用最多的。主要三点：
- 子类构造函数的__proto__指向父类构造器，继承父类的静态方法
- 子类构造函数的prototype的__proto__指向父类构造的prototype，继承父类的方法
- 子类构造器里调用父类构造器，继承父类的属性。
1. 原型链的方式实现继承
2. 借用构造函数的方式
3. 组合继承
4. 原型式继承
5. 寄生式继承
6. 寄生式组合继承
##### 18.This指向
1. 全局上下文
   非严格模式和严格模式中this都是指向顶层对象(浏览器中是window)
2. 默认绑定
   独立函数调用，这条规则可以看做是无法应用其他规则时的默认规则。
3. 隐式绑定
   这条规则需要考虑的是调用位置是否有上下文对象，或者说被某个对象拥有或者包含。
4. 显示绑定
##### 19.设计模式
1. 工厂模式
2. 单例模式(在Vue中熟知的Vuex)
3. 适配器模式
4. 装饰器模式
5. 代理模式
6. 观察者模式(发布-订阅模式)
##### 20.防抖和节流
	防抖：对于短时间内连续触发的事件，防抖的含义就是让某个时间期限内，事件处理函数只执行一次。
```javascript
function debounce(fn,delay){
    let timer = null;
    return function(){
        if(timer){
        	clearTimeout(timer)
        }
        timer = setTimeout(fn,delay)
    }
}
```
	节流：如果在限定时间内，不断触发滚动时间，只要不停止触发，理论上就永远不会输出当前距离顶部的距离。
```javascript
function throttle(fn,delay){
	let valid = true;
	return function(){
		if(!valid){
			return false
		}
		valid = false;
		setTimeout(() => {
			fn();
			valid = true;
		},delay)
	}
}
```
##### 21.闭包
> 什么是闭包？

  当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。
  闭包产生的本质是，当前环境中存在指向父级作用域的引用。
> 闭包的应用

1. 定时器
2. 事件监听器
3. ajax
4. 异步(同步)操作
5. 模块

##### 22.数组去重
1. 双循环实现
   它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存。
2. indexOf()去重
   循环 + indexOf()；
   调用indexOf()方法对原来的数组进行遍历判断，如果元素不在res中，则将其push进res中
3. indexOf()去重 + filter
   利用indexOf()检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素。
4. 相邻元素去重
   首先调用数组的排序方法sort()，然后根据排序后的结果进行遍历级相邻元素，如果相等则跳过该元素。
5. 利用对象属性去重
6. set与结构赋值去重
##### 23.深浅拷贝
	浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改变原对象。
	浅拷贝只是拷贝基本类型的数据，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，因此存在父对象被篡改的问题，浅拷贝只是复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存。
	深拷贝就是能够实现真正意义上的数组和对象的拷贝。
##### 24.判断数据类型
1. typeof
2. instanceof
3. constructor
4. prototype
##### 25.原型对象和构造函数
	在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会自带一个prototype属性，这个属性指向函数的原型对象。当函数经过new调用时，这个函数就成为了构造函数，返回了一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。